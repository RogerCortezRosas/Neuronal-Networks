# -*- coding: utf-8 -*-
"""Primera Red Convolucional.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/149vfEa3LKbw-02pGVa9ox6cqLBLJ8ZoS
"""

import tensorflow as tf
from tensorflow.keras.datasets import fashion_mnist
from tensorflow.keras.layers import Conv2D, Dropout, MaxPooling2D, Flatten, Dense
# Helper libraries
import numpy as np
import matplotlib.pyplot as plt

"""### La data que se va a ocupar se trata de imagenes de distintos tipos de ropa y nuetra red tendra que identificar a que prenda o accesorio corresponde la imagen"""

(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()

train_images.shape # Son 60,000 imagenes que de 28 x 28 pixeles

plt.imshow(train_images[99])

"""# Limpieza de datos"""

train_images = train_images.astype('float32') / 255 # Se divide entre 255 porque el valor de un pixel es de 1 a 255 y al dividirlo tendriamos valores de 0 a 1 , y asi trabaje mejor la red neuronal
test_images = test_images.astype('float32') / 255

train_images = train_images.reshape(train_images.shape[0], 28, 28, 1) # El 1 al final es el canal del color
test_images = test_images.reshape(test_images.shape[0], 28, 28, 1)

train_labels[0] # El valor en la posicion 0 es clasificado como 9

train_labels = tf.keras.utils.to_categorical(train_labels, 10) # Es 10 porque solo tenemos 10 posibles valores de salida
test_labels = tf.keras.utils.to_categorical(test_labels, 10)

train_labels[0] # Lo que hizo la funcion to_categorical fue converstir el valor escalar a un arreglo binario en donde habra un 1 en la poscion que corrsponde al valor escalar

"""# Creacion del modelo"""

